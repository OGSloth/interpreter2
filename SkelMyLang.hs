-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelMyLang where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified AbsMyLang

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: AbsMyLang.Ident -> Result
transIdent x = case x of
  AbsMyLang.Ident string -> failure x

transProgram :: AbsMyLang.Program -> Result
transProgram x = case x of
  AbsMyLang.Prog topdefs -> failure x

transTopDef :: AbsMyLang.TopDef -> Result
transTopDef x = case x of
  AbsMyLang.FnDef type_ ident args block -> failure x

transArg :: AbsMyLang.Arg -> Result
transArg x = case x of
  AbsMyLang.Argum type_ ident -> failure x

transBlock :: AbsMyLang.Block -> Result
transBlock x = case x of
  AbsMyLang.Bloc stmts -> failure x

transStmt :: AbsMyLang.Stmt -> Result
transStmt x = case x of
  AbsMyLang.Empty -> failure x
  AbsMyLang.BStmt block -> failure x
  AbsMyLang.Decl type_ items -> failure x
  AbsMyLang.ConstDecl type_ items -> failure x
  AbsMyLang.Ass ident expr -> failure x
  AbsMyLang.ArrAss ident exprs expr -> failure x
  AbsMyLang.TupAss ident expr1 expr2 -> failure x
  AbsMyLang.Ret expr -> failure x
  AbsMyLang.VRet -> failure x
  AbsMyLang.Cond expr stmt -> failure x
  AbsMyLang.CondElse expr stmt1 stmt2 -> failure x
  AbsMyLang.While expr stmt -> failure x
  AbsMyLang.For ident expr1 expr2 stmt -> failure x
  AbsMyLang.Print exprs -> failure x
  AbsMyLang.Break -> failure x
  AbsMyLang.Continue -> failure x
  AbsMyLang.SExp expr -> failure x

transItem :: AbsMyLang.Item -> Result
transItem x = case x of
  AbsMyLang.NoInit ident -> failure x
  AbsMyLang.Init ident expr -> failure x
  AbsMyLang.ArrayInit ident exprs -> failure x

transType :: AbsMyLang.Type -> Result
transType x = case x of
  AbsMyLang.SimpleType stype -> failure x
  AbsMyLang.CollectionType ctype -> failure x

transCType :: AbsMyLang.CType -> Result
transCType x = case x of
  AbsMyLang.Array stype -> failure x
  AbsMyLang.Tuple types -> failure x

transSType :: AbsMyLang.SType -> Result
transSType x = case x of
  AbsMyLang.Int -> failure x
  AbsMyLang.Str -> failure x
  AbsMyLang.Bool -> failure x
  AbsMyLang.Void -> failure x

transExpr :: AbsMyLang.Expr -> Result
transExpr x = case x of
  AbsMyLang.EVar ident -> failure x
  AbsMyLang.ELitInt integer -> failure x
  AbsMyLang.ELitTrue -> failure x
  AbsMyLang.ELitFalse -> failure x
  AbsMyLang.EApp ident exprs -> failure x
  AbsMyLang.EString string -> failure x
  AbsMyLang.EArr ident exprs -> failure x
  AbsMyLang.ETup ident expr -> failure x
  AbsMyLang.Neg expr -> failure x
  AbsMyLang.Not expr -> failure x
  AbsMyLang.EMul expr1 mulop expr2 -> failure x
  AbsMyLang.EAdd expr1 addop expr2 -> failure x
  AbsMyLang.ERel expr1 relop expr2 -> failure x
  AbsMyLang.EAnd expr1 expr2 -> failure x
  AbsMyLang.EOr expr1 expr2 -> failure x

transAddOp :: AbsMyLang.AddOp -> Result
transAddOp x = case x of
  AbsMyLang.Plus -> failure x
  AbsMyLang.Minus -> failure x

transMulOp :: AbsMyLang.MulOp -> Result
transMulOp x = case x of
  AbsMyLang.Times -> failure x
  AbsMyLang.Div -> failure x
  AbsMyLang.Mod -> failure x

transRelOp :: AbsMyLang.RelOp -> Result
transRelOp x = case x of
  AbsMyLang.LTH -> failure x
  AbsMyLang.LE -> failure x
  AbsMyLang.GTH -> failure x
  AbsMyLang.GE -> failure x
  AbsMyLang.EQU -> failure x
  AbsMyLang.NE -> failure x
  AbsMyLang.TR -> failure x
